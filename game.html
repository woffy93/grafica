<html>
	<head>
		<title>Game</title>
		<style>
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
		
		canvas { 
			width: 100%; 
			height: 100%;
		}
		</style>
		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/OBJLoader.js"></script>
		<script src="lib/MTLLoader.js"></script>
		<script src="lib/OrbitControls.js"></script>
		<script src="http://dat-gui.googlecode.com/git/build/dat.gui.min.js"></script>
	</head>
	<body>
		
		<script>
//==========VARIABLES================================================
			var camera1, camera2, scene, renderer,clock;
			var player1, asteroid, laser,p;
			var mx=0;var mz=0;
			var asteroids = new Array();
			var rays;
			var euler = new THREE.Euler( 0, 0, 0, 'XYZ' );

			var rotationVector = new THREE.Vector3( 0, 0, 0 );
				var moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 };
				
			rays = [
				    new THREE.Vector3(0, 0, 1),
				    new THREE.Vector3(1, 0, 1),
				    new THREE.Vector3(1, 0, 0),
				    new THREE.Vector3(1, 0, -1),
				    new THREE.Vector3(0, 0, -1),
				    new THREE.Vector3(-1, 0, -1),
				    new THREE.Vector3(-1, 0, 0),
				    new THREE.Vector3(-1, 0, 1),
				    new THREE.Vector3(0, 1, 0),	//up
				    new THREE.Vector3(0, -1, 0)	//down
				    ];

			var currentCamera = {
				cam : "cam1"
			}

			var Player ={
				mesh : new THREE.Mesh(),
				targets : new Array(),
				move : new THREE.Vector3(0,0,0),
				roll : new THREE.Vector3(0,0,0),
				is_alive : true,
				objLoad : false,
				LoadObj : function (path){
					var mtlLoader = new THREE.MTLLoader();
					mtlLoader.load( 
						path+'.mtl', 
						function( materials ) {
							materials.preload();
							var objLoader = new THREE.OBJLoader();
							objLoader.setMaterials( materials );
							objLoader.load( 
								path+'.obj', 
								function ( mesh ) {	// onload
									Player.mesh=mesh;
									Player.settt(true);
									scene.add(Player.mesh);
								}
							);
						}
					);
				},
				settt : function(b){
					this.objLoad=b;
				},
				create : function (){
					this.LoadObj("models/starwars-tie-fighter");
					
				},
				update : function(){
					console.log("up");
				}
			};
			init();
			render();

			
//==========FUNCTIONS============================================================================================
			function init() {
				clock = new THREE.Clock();
				renderer = new THREE.WebGLRenderer();
				renderer.setSize(window.innerWidth, window.innerHeight);
				document.body.appendChild(renderer.domElement);

				//CAMERAS----------------------------------------------------------------------------------------
				camera1 = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
				camera1.position.x = 2*(Math.PI)
				camera1.position.z = 10;
				camera2 = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
				camera2.position.set(0,0,0);	
				
				//Controls---------------------------------------------------------------------------------------		
				controls = new THREE.OrbitControls( camera1, renderer.domElement);
				controls.enableDamping = true;
				controls.dampingFactor = 0.25;
				controls.enableZoom = true;

				scene = new THREE.Scene();

				// var mtlLoader = new THREE.MTLLoader();	//load player
				// mtlLoader.load( 'models/starwars-tie-fighter.mtl', function( materials ) {

				// 	materials.preload();

				// 	var objLoader = new THREE.OBJLoader();
				// 	objLoader.setMaterials( materials );
				// 	objLoader.load( 'models/starwars-tie-fighter.obj', function ( mesh ) {
				// 		player1=mesh;
				// 		scene.add(player1);

				// 	} );

				// });

				//Player-test----------------------------------------------------------------------------------
				Player.create();
				//Asteroid-Test-----------------------------------------------------------------------------------
				asteroid = new Asteroid();
				asteroid.position.x=-20;
				asteroid.move_active=false;
				asteroid.roll.active=false;
				asteroid.roll.x=1;
				asteroid.roll.y=1;
				// var point=[
				// 	new THREE.Vector3(-20,0,0),
				// 	new THREE.Vector3(20,0,0)
				//  ];
				var point=[
					new THREE.Vector3(-20,5,0),
					new THREE.Vector3(-10,-5,0),
					new THREE.Vector3(0,5,0),
					new THREE.Vector3(10,-5,0),
					new THREE.Vector3(20,5,0)
				];
				asteroid.direction(point);
				asteroid.radius=5;
				scene.add(asteroid.createAsteroid());

				// for (var i = 0; i <20; i++) {	
				// 	asteroids.push(new Asteroid());
				// 	asteroids[i].position.z=-8*i;
				// 	console.log(asteroids[i].position.z)
				// 	var randomPoints = [];
				// 	for ( var j = 0; j < 100; j ++ ) {
				// 	    randomPoints.push(
				// 	        new THREE.Vector3(Math.random() * 200 - 100, Math.random() * 200 - 100, Math.random() * 200 - 100)
				// 	    );
				// 	}
				// 	asteroids[i].direction(randomPoints);
				// 	asteroids[i].radius=3;
				// 	asteroids[i].move_active=true;
				// 	asteroids[i].roll.active=true;
				// 	asteroids[i].roll.x=1;
				// 	asteroids[i].roll.y=1;
				// 	//if(asteroids[i] != undefined)
				// 	scene.add(asteroids[i].createAsteroid());
				// }
			 	
				//LIGHT------------------------------------------
			 	var ambientLight = new THREE.AmbientLight( 0x444444 );
				scene.add( ambientLight );

				var directLight = new THREE.DirectionalLight( 0xffffff ,0.5);
				directLight.position.set(0,0,5);
				scene.add( directLight );

				//STATS-------------------------------------------
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				document.body.appendChild( stats.domElement );

			}//init-end

			//============checkCollisions===============
		 	function checkCollisions (playermesh,rayslist,meshlist){
		 		var raycast = new THREE.Raycaster();
		 		for (var i = 0; i < rayslist.length; i++) {
					raycast.set(playermesh.position,rayslist[i]);
					var collisions = raycast.intersectObjects(meshlist,true);
					if(collisions.length>0 && collisions[0].distance<=5)
					{
						scene.remove(Player.mesh);
					}
				}
		 	}

			//GUI-------------------------------------				
			window.onload = function() {
				var gui = new dat.GUI();
				gui.add(currentCamera, 'cam', { inspect: "cam1", player: "cam2"} );
				gui.add(asteroid, 'move_active');
				gui.add(asteroid.roll, 'active');
  			}
  			function cameraSelector() {
				if (currentCamera.cam=="cam1"){
					return camera1;
				} else if (currentCamera.cam=="cam2"){
					return camera2;
				}
			}

  			window.addEventListener('keydown', function(event) {
  				if(currentCamera.cam=="cam2"){
					switch (event.keyCode) {
						case 65: // Left
							mx+=0.1;
						break;
						case 87: // Up
							mz+=0.1;
						break;
						case 68: // Right
							mx-=0.1;
						break;
						case 83: // Down
							mz-=0.1;
						break;
						case 69: // Down
							laser= new Laser();
 					 		if(Player.objLoad)
 					 			scene.add(laser.createLaser(Player.mesh));
						break;

					}
				}
	  		})
  			//-----Resize-------------------------
  			window.addEventListener( 'resize', onWindowResize, true);
  			function onWindowResize() {
				camera1.aspect = window.innerWidth / window.innerHeight;
				camera1.updateProjectionMatrix();
				camera2.aspect = window.innerWidth / window.innerHeight;
				camera2.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			//Mouse-Functions--------------------------------------------------------
  			function updateRotationVector() {
	  			if(currentCamera.cam=="cam2"){
					rotationVector.x = ( + moveState.pitchDown - moveState.pitchUp );
					rotationVector.y = ( - moveState.yawRight  + moveState.yawLeft );
					rotationVector.z = ( - moveState.rollRight + moveState.rollLeft );
				}	
			}
			mouseup = function( event ) {
				event.preventDefault();
				event.stopPropagation();
				if (window.dragToLook ) {
					window.mouseStatus --;
					moveState.yawLeft = moveState.pitchDown = 0;
				} else {
					switch ( event.button ) {
						case 0: moveState.forward = 0; break;
						case 2: moveState.back = 0; break;
					}
					updateMovementVector();
				}
				updateRotationVector();
			};
			window.onmousemove = function( event ) {
				var container = this.getContainerDimensions();
				var halfWidth  = container.size[ 0 ] / 2;
				var halfHeight = container.size[ 1 ] / 2;
				moveState.yawLeft   = - ( ( event.pageX) - halfWidth  ) / halfWidth;
				moveState.pitchDown =   ( ( event.pageY) - halfHeight ) / halfHeight;
				updateRotationVector();
			}
			window.getContainerDimensions = function() {
				return {
					size	: [ window.innerWidth, window.innerHeight ],
					offset	: [ 0, 0 ]
				};
			};
	
			//RENDER--------------------------------------------------------------------------
			function render() {
				requestAnimationFrame(render);
				
				stats.update();
				// for (var i = 0; i <20; i++) {
				// 	if(asteroids[i] != undefined){
				// 		asteroids[i].update();
				// 	}else
				// 	console.log("asteroid undefined")
					
				// }
				//console.log(rotationVector.x);
				if(laser != undefined){
					laser.update();
				}

				if(asteroid != undefined){
					asteroid.update();
				}
				console.log(Player.objLoad);
				if (Player.objLoad) {

					Player.mesh.quaternion.setFromEuler(new THREE.Euler(
						rotationVector.x*(Math.PI/2),
						rotationVector.y*(Math.PI),
						rotationVector.z,
						'ZYX' ));
					
					var relativeCameraOffset = new THREE.Vector3 (0,5,-10);
					var cameraOffset = relativeCameraOffset.applyMatrix4( Player.mesh.matrixWorld );

					camera2.position.x = cameraOffset.x;
					camera2.position.y = cameraOffset.y;
					camera2.position.z = cameraOffset.z;
					camera2.rotation.y = 90 * Math.PI / 180;
					camera2.rotation.z = Math.PI;
					camera2.lookAt(Player.mesh.position);

					var delta = clock.getDelta(); // seconds.
					Player.mesh.translateZ(mz);
					Player.mesh.translateX(mx);
					mx/=1.05;
					mz/=1.05;

					checkCollisions(Player.mesh,rays,[asteroid.asteroid_mesh]);
				}
				renderer.render(scene, cameraSelector());
			}

//===========OBJECT======================================================

//====ASTEROID===========================================================
function Asteroid () {	// constructor asteroid
					this.d_inc = 20;	//% max increase
					this.d_dec = 20;	//% max decrease
					this.radius = 1;
					this.detail = 2;
					this.position = {
						x : 0,
						y : 0,
						z : 0
					};
					this.roll = {
						active : true,
						x : 0,	// rad/30
						y : 0,
						z : 0,
						max : 10,
						min : -10
					};			
					this.move_active = true;
					this.visible = true;
					this.n_steps = 400;
					this.step = 0;
					this.material = new THREE.MeshLambertMaterial({
															color : 0x757778,
															emissive : 0x222222
															});
					this.spline = new THREE.CatmullRomCurve3();
					this.asteroid_mesh = new THREE.Mesh();
					this.direction = function(point){
						this.spline = new THREE.CatmullRomCurve3(point);

					};
					this.createAsteroid = function(){
						var asteroid_geo = this.AsteroidGeometry(this.radius,this.detail, this.d_inc,this.d_dec);
					    this.asteroid_mesh = new THREE.Mesh(asteroid_geo, this.material);
						this.asteroid_mesh.position.set(this.position.x,
														this.position.y,
														this.position.z);
						this.asteroid_mesh.visible=this.visible;
						return this.asteroid_mesh;
					};
					this.AsteroidGeometry = function (radius , detail, inc , dec){
						var octahedron_geo = new THREE.OctahedronGeometry(radius,detail);
						for(var i=0;i<octahedron_geo.vertices.length;i++){
							var v_a = octahedron_geo.vertices[i].toArray();
							var ran_value=Math.random()*((1+inc/100)-(1-dec/100))+(1-dec/100);	
							octahedron_geo.vertices[i]=new THREE.Vector3(v_a[0]*ran_value,
																		 v_a[1]*ran_value,
																		 v_a[2]*ran_value);
						}
						return octahedron_geo;
					};
					this.update = function (){
						if(this.move_active==true){
							if(this.step>this.n_steps)
							this.step=0;
							var camPos = this.spline.getPoint(this.step++ / this.n_steps);
							this.position.x = camPos .x;
							this.position.y = camPos .y;
							this.position.z = camPos .z;
						}
						if(this.roll.active){
							this.asteroid_mesh.rotation.x+= (this.roll.x/60);
							this.asteroid_mesh.rotation.y+= (this.roll.y/60);
							this.asteroid_mesh.rotation.z+= (this.roll.z/60);
						}
						this.asteroid_mesh.position.set(this.position.x,
														this.position.y,
														this.position.z);
						this.asteroid_mesh.visible=this.visible;
					};
				}
//=====END=ASTEROID======================================================

//=========LASER=========================================================
			 	function Laser() {
			 		this.move_active = true;
			 		this.geometry = new THREE.CylinderGeometry( 0.03, 0.03, 1, 32 );
			 		this.material = new THREE.MeshPhongMaterial({
														color : 0xff0000,
														emissive :0xca0000,
														shininess :100
													});
			 		this.laser_mesh = new THREE.Mesh(this.geometry, this.material);
			 		this.spline = new THREE.CatmullRomCurve3();
			 		this.rays = [new THREE.Vector3(0,0,1)];
			 		this.n_step = 200;
			 		this.step = 0;
			 		this.createLaser = function(player){
			 			var relativeLaserOffset = new THREE.Vector3 (0.35,-0.95, 8);
						var laserOffset = relativeLaserOffset.applyMatrix4( player.matrixWorld );
						this.laser_mesh.position.x = laserOffset.x;
						this.laser_mesh.position.y = laserOffset.y;
						this.laser_mesh.position.z = laserOffset.z;

			 		// 	var laser_geo = new THREE.CylinderGeometry( 0.03, 0.03, 1, 16 );
						// laser_geo.rotateX (Math.PI)/2;
						// this.laser_mesh=new THREE.Mesh(laser_geo,this.material);

						//set fire tragectory
						this.spline = new THREE.CatmullRomCurve3([
																	this.laser_mesh.position,
																	new THREE.Vector3(0,0,40)
																]);

						return this.laser_mesh;
			 		};
			 		this.update = function(){
			 			if(this.move_active==true){
							while (this.laser_mesh.position.z<2000)
							this.laser_mesh.position.z++;
						};
			 		}


			 	}
//======END=LASER=======================================================

		</script>
	</body>
</html>
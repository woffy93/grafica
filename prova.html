<html>
	<head>
		<title>Game</title>
		<style>
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
		
		canvas { 
			width: 100%; 
			height: 100%;
		}
		</style>
		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/OBJLoader.js"></script>
		<script src="lib/MTLLoader.js"></script>
		<script src="lib/OrbitControls.js"></script>
		<script src="http://dat-gui.googlecode.com/git/build/dat.gui.min.js"></script>
	</head>
	<body>
		
		<script>
			var camera1, camera2, scene, renderer,clock;
			var player1, asteroid, laser;
			var mx=0;var mz=0;
			var rays;
			rays = [
				    new THREE.Vector3(0, 0, 1),
				    new THREE.Vector3(1, 0, 1),
				    new THREE.Vector3(1, 0, 0),
				    new THREE.Vector3(1, 0, -1),
				    new THREE.Vector3(0, 0, -1),
				    new THREE.Vector3(-1, 0, -1),
				    new THREE.Vector3(-1, 0, 0),
				    new THREE.Vector3(-1, 0, 1),
				    new THREE.Vector3(0, 1, 0),	//up
				    new THREE.Vector3(0, -1, 0)	//down
				    ];

			var currentCamera = {
					cam : "cam1"
				}

			init();
			render();

			function init() {
				clock = new THREE.Clock();
				renderer = new THREE.WebGLRenderer();
				renderer.setSize(window.innerWidth, window.innerHeight);
				document.body.appendChild(renderer.domElement);

				camera1 = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
				camera1.position.x = 2*(Math.PI)
				camera1.position.z = 10;
				controls = new THREE.OrbitControls( camera1, renderer.domElement);
				controls.enableDamping = true;
				controls.dampingFactor = 0.25;
				controls.enableZoom = true;

				camera2 = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
				camera2.position.set(0,0,0);

				scene = new THREE.Scene();

				var mtlLoader = new THREE.MTLLoader();	//load player
				mtlLoader.load( 'models/starwars-tie-fighter.mtl', function( materials ) {

					materials.preload();

					var objLoader = new THREE.OBJLoader();
					objLoader.setMaterials( materials );
					objLoader.load( 'models/starwars-tie-fighter.obj', function ( mesh ) {
						player1=mesh;
						scene.add(player1);

					} );

				});

				var geometry = new THREE.CylinderGeometry( 0.03, 0.03, 1, 32 ); var material = new THREE.MeshBasicMaterial( {color: 0xff0000} );
				laser = new THREE.Mesh( geometry, material ); 
				laser.position.set(2,2,2);
				laser.rotation.x = (Math.PI)/2;
				scene.add( laser );


				Asteroid = {	//load asteroid
					d_inc : 20,	//% max increase
					d_dec : 20,	//% max decrease
					radius : 1,
					detail : 2,
					position : {
						x : 0,
						y : 0,
						z : 0
					},
					roll : {
						active : true,
						x : 0,	// rad/30
						y : 0,
						z : 0,
						max : 10,
						min : -10,
					},			
					move_active : true,
					visible : true,
					n_steps :400,
					step : 0,
					material : new THREE.MeshLambertMaterial({
															color : 0x757778,
															emissive :0x222222
															}),
					spline : new THREE.CatmullRomCurve3(),
					asteroid_mesh : new THREE.Mesh(),
					direction : function(point){
						this.spline = new THREE.CatmullRomCurve3(point);

					},
					createAsteroid : function(){
						var asteroid_geo = this.AsteroidGeometry(this.radius,this.detail, this.d_inc,this.d_dec);
					    this.asteroid_mesh = new THREE.Mesh(asteroid_geo, this.material);
						this.asteroid_mesh.position.set(this.position.x,
														this.position.y,
														this.position.z);
						this.asteroid_mesh.visible=this.visible;
						return this.asteroid_mesh;
					},
					AsteroidGeometry : function (radius , detail, inc , dec){
						var octahedron_geo = new THREE.OctahedronGeometry(radius,detail);
						for( i=0;i<octahedron_geo.vertices.length;i++){
							var v_a = octahedron_geo.vertices[i].toArray();
							var ran_value=Math.random()*((1+inc/100)-(1-dec/100))+(1-dec/100);	
							octahedron_geo.vertices[i]=new THREE.Vector3(v_a[0]*ran_value,
																		 v_a[1]*ran_value,
																		 v_a[2]*ran_value);
						}
						return octahedron_geo;
					},
					update : function (){
						if(this.move_active==true){
							if(this.step>this.n_steps)
							this.step=0;
							var camPos = this.spline.getPoint(this.step++ / this.n_steps);
							this.position.x = camPos .x;
							this.position.y = camPos .y;
							this.position.z = camPos .z;
						}
						if(this.roll.active){
							this.asteroid_mesh.rotation.x+= (this.roll.x/60);
							this.asteroid_mesh.rotation.y+= (this.roll.y/60);
							this.asteroid_mesh.rotation.z+= (this.roll.z/60);
						}
						this.asteroid_mesh.position.set(this.position.x,
														this.position.y,
														this.position.z);
						this.asteroid_mesh.visible=this.visible;
					}
				}

				
				//============ Asteroid Test================
					 asteroid =Object.create(Asteroid);
					 asteroid.position.x=-20;
					 asteroid.move_active=false;
					 asteroid.roll.active=false;
					 asteroid.roll.x=1;
					 asteroid.roll.y=1;
					// var point=[
					// 	new THREE.Vector3(-20,0,0),
					// 	new THREE.Vector3(20,0,0)
					//  ];
					 var point=[
						new THREE.Vector3(-20,5,0),
						new THREE.Vector3(-10,-5,0),
						new THREE.Vector3(0,5,0),
						new THREE.Vector3(10,-5,0),
						new THREE.Vector3(20,5,0)
					 ];
					 
					  asteroid.direction(point);
					  asteroid.radius=5;

					  scene.add(asteroid.createAsteroid());
				//==========================================
			 	//=========LASER============================
			 	Laser = {
			 		position : {
			 			x : 0,
			 			y : 0,
			 			z : 0
			 		},
			 		move_active : true,
			 		material : new THREE.MeshPhongMaterial({
														color : 0xff0000,
														emissive :0xca0000,
														shininess :100
													}),
			 		laser_mesh : new THREE.Mesh(),
			 		spline : new THREE.CatmullRomCurve3(),
			 		rays : [new THREE.Vector3(0,0,1)],
			 		n_step : 200,
			 		step : 0,
			 		createLaser : function(player){
			 			var laser_geo = new THREE.CylinderGeometry( 0.03, 0.03, 1, 16 );
						laser_geo.rotateX (Math.PI)/2;
						this.laser_mesh=new THREE.Mesh(laser_geo,this.material);
						var relativeLaserOffset = new THREE.Vector3 (0.35,-0.95, 8);
						var laserOffset = relativeLaserOffset.applyMatrix4( player.matrixWorld );
						this.laser_mesh.position.x = laserOffset.x;
						this.laser_mesh.position.y = laserOffset.y;
						this.laser_mesh.position.z = laserOffset.z;

						//set fire tragectory
						this.spline = new THREE.CatmullRomCurve3([
																	this.laser_mesh.position,
																	new THREE.Vector3(0,0,40)
																]);

						return this.laser_mesh;
			 		},
			 		update : function(){
			 			if(this.move_active==true){
							if(this.step>this.n_steps)
							this.step=0;
							var laserPos = this.spline.getPoint(this.step++ / this.n_steps);
							this.laser_mesh.position.x = laserPos.x;
							this.laser_mesh.position.y = laserPos.y;
							this.laser_mesh.position.z = laserPos.z;
						}
			 		}


			 	}
			 	//==========================================

			 	var ambientLight = new THREE.AmbientLight( 0x444444 );
				scene.add( ambientLight );

				var directLight = new THREE.DirectionalLight( 0xffffff ,0.5);
				directLight.position.set(0,0,5);
				scene.add( directLight );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				document.body.appendChild( stats.domElement );


			}

				//============checkCollisions===============
			 	function checkCollisions (playermesh,rayslist,meshlist){
			 		var raycast = new THREE.Raycaster();
			 		for (i = 0; i < rayslist.length; i++) {
						raycast.set(playermesh.position,rayslist[i]);
						var collisions = raycast.intersectObjects(meshlist,true);

						if(collisions.length>0 && collisions[0].distance<=5)
						{
							scene.remove(player1);
						}
					}
			 	}
			 	//===========================================

				function cameraSelector() {
					if (currentCamera.cam=="cam1"){
						return camera1;
					} else if (currentCamera.cam=="cam2"){
						return camera2;
					}
				}



				
				window.onload = function() {
					var gui = new dat.GUI();
					gui.add(currentCamera, 'cam', { inspect: "cam1", player: "cam2"} );
					gui.add(asteroid, 'move_active');
					gui.add(asteroid.roll, 'active');
	  			}

	  			window.addEventListener('keydown', function(event) {
  							switch (event.keyCode) {
  								case 65: // Left
  								mx+=0.1;
  								break;
  								case 87: // Up
  								mz+=0.1;
  								break;
  								case 68: // Right
  								mx-=0.1;
  								 break;
  								 case 83: // Down
  								 mz-=0.1;
  								 break;
  							}
  						})

//=========================== MOUSE TEST =================================================================================================================================

				var rotationVector = new THREE.Vector3( 0, 0, 0 );
				var moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 };

	  			function updateRotationVector() {
				rotationVector.x = ( - moveState.pitchDown + moveState.pitchUp );
				rotationVector.y = ( - moveState.yawRight  + moveState.yawLeft );
				rotationVector.z = ( - moveState.rollRight + moveState.rollLeft );
				//console.log(rotationVector.x);
			
				}
				mouseup = function( event ) {
						event.preventDefault();
						event.stopPropagation();

						if (window.dragToLook ) {
							window.mouseStatus --;

							moveState.yawLeft = moveState.pitchDown = 0;

						} else {

							switch ( event.button ) {

								case 0: moveState.forward = 0; break;
								case 2: moveState.back = 0; break;

							}

							updateMovementVector();

						}

						updateRotationVector();

					};
					
				window.onmousemove = function( event ) {
					var container = this.getContainerDimensions();
					var halfWidth  = container.size[ 0 ] / 2;
					var halfHeight = container.size[ 1 ] / 2;

					moveState.yawLeft   = - ( ( event.pageX) - halfWidth  ) / halfWidth;
					moveState.pitchDown =   ( ( event.pageY) - halfHeight ) / halfHeight;

					updateRotationVector();

				}

				window.getContainerDimensions = function() {
					return {
						size	: [ window.innerWidth, window.innerHeight ],
						offset	: [ 0, 0 ]
					};
				};


//====================================================================================================================================================================

				
				function render() {
					requestAnimationFrame(render);
					
					stats.update();
					if(asteroid != undefined){
						asteroid.update();
						
					}
					if (player1 != undefined) {
						player1.rotation.x=rotationVector.x;
						player1.rotation.y=rotationVector.y;
						player1.rotation.z=rotationVector.z;
						var relativeCameraOffset = new THREE.Vector3 (0,5,-10);
						var cameraOffset = relativeCameraOffset.applyMatrix4( player1.matrixWorld );

						camera2.position.x = cameraOffset.x;
						camera2.position.y = cameraOffset.y;
						camera2.position.z = cameraOffset.z;
						camera2.rotation.y = 90 * Math.PI / 180;
						camera2.lookAt(player1.position);

						
						
						var delta = clock.getDelta(); // seconds.
						//var moveDistance = 0.02* delta; // 200 pixels per second
						player1.translateZ(mz);
						player1.translateX(mx);
						mx/=1.05;
						mz/=1.05;
						checkCollisions(player1,rays,[asteroid.asteroid_mesh]);
					}

					renderer.render(scene, cameraSelector());

				}

		</script>
	</body>
</html>
<html>
	<head>
		<title>Game</title>
		<style>
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
		
		canvas { 
			width: 100%; 
			height: 100%;
		}
		</style>
		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/OBJLoader.js"></script>
		<script src="lib/MTLLoader.js"></script>
		<script src="lib/OrbitControls.js"></script>
		<script src="http://dat-gui.googlecode.com/git/build/dat.gui.min.js"></script>
	</head>
	<body>
		
		<script>
			var camera1, camera2, scene, renderer,clock;
			var player1, asteroid, laser;

			var currentCamera = {
					cam : "cam1"
				}

			init();
			render();

			function init() {
				clock = new THREE.Clock();
				renderer = new THREE.WebGLRenderer();
				renderer.setSize(window.innerWidth, window.innerHeight);
				document.body.appendChild(renderer.domElement);

				camera1 = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
				camera1.position.x = 2*(Math.PI)
				camera1.position.z = 10;
				controls = new THREE.OrbitControls( camera1, renderer.domElement);
				controls.enableDamping = true;
				controls.dampingFactor = 0.25;
				controls.enableZoom = true;

				camera2 = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
				camera2.position.set(0,0,0);

				scene = new THREE.Scene();

				var mtlLoader = new THREE.MTLLoader();	//load player
				mtlLoader.load( 'models/starwars-tie-fighter.mtl', function( materials ) {

					materials.preload();

					var objLoader = new THREE.OBJLoader();
					objLoader.setMaterials( materials );
					objLoader.load( 'models/starwars-tie-fighter.obj', function ( mesh ) {
						player1=mesh;
						scene.add(player1);

					} );

				});

				var geometry = new THREE.CylinderGeometry( 0.03, 0.03, 1, 32 ); var material = new THREE.MeshBasicMaterial( {color: 0xff0000} );
				laser = new THREE.Mesh( geometry, material ); 
				laser.position.set(2,2,2);
				laser.rotation.x = (Math.PI)/2;
				scene.add( laser );


				Asteroid = {	//load asteroid
					d_inc : 20,	//% max increase
					d_dec : 20,	//% max decrease
					radius : 1,
					detail : 2,
					position : {
						x : 0,
						y : 0,
						z : 0
					},
					roll : {
						active : true,
						x : 0,	// rad/30
						y : 0,
						z : 0,
						max : 10,
						min : -10,
					},			
					move_active : true,
					visible : true,
					n_steps :500,
					step : 0,
					material : new THREE.MeshLambertMaterial({
															color : 0x757778,
															emissive :0x222222
															}),
					spline : new THREE.CatmullRomCurve3(),
					asteroid_mesh : new THREE.Mesh(),
					direction : function(point){
						this.spline = new THREE.CatmullRomCurve3(point);
					},
					createAsteroid : function(){
						var asteroid_geo = this.AsteroidGeometry(this.radius,this.detail, this.d_inc,this.d_dec);
					    this.asteroid_mesh = new THREE.Mesh(asteroid_geo, this.material);
						this.asteroid_mesh.position.set(this.position.x,
														this.position.y,
														this.position.z);
						this.asteroid_mesh.visible=this.visible;
						return this.asteroid_mesh;
					},
					AsteroidGeometry : function (radius , detail, inc , dec){
						var octahedron_geo = new THREE.OctahedronGeometry(radius,detail);
						for( i=0;i<octahedron_geo.vertices.length;i++){
							var v_a = octahedron_geo.vertices[i].toArray();
							var ran_value=Math.random()*((1+inc/100)-(1-dec/100))+(1-dec/100);	
							octahedron_geo.vertices[i]=new THREE.Vector3(v_a[0]*ran_value,
																		 v_a[1]*ran_value,
																		 v_a[2]*ran_value);
						}
						return octahedron_geo;
					},
					update : function (){
						if(this.move_active==true){
							if(this.step>this.n_steps)
							this.step=0;
							var camPos = this.spline.getPoint(this.step++ / this.n_steps);
							this.position.x = camPos .x;
							this.position.y = camPos .y;
							this.position.z = camPos .z;
						}
						if(this.roll.active){
							this.asteroid_mesh.rotation.x+= (this.roll.x/60);
							this.asteroid_mesh.rotation.y+= (this.roll.y/60);
							this.asteroid_mesh.rotation.z+= (this.roll.z/60);
						}
						this.asteroid_mesh.position.set(this.position.x,
														this.position.y,
														this.position.z);
						this.asteroid_mesh.visible=this.visible;
					}
				}

				
				//============ Asteroid Test================
					 asteroid =Object.create(Asteroid);
					 asteroid.position.x=-20;
					 asteroid.move_active=false;
					 asteroid.roll.active=false;
					 asteroid.roll.x=1;
					 asteroid.roll.y=1;
					var point=[
						new THREE.Vector3(-20,0,0),
						new THREE.Vector3(20,0,0)
					 ];

					 asteroid.direction(point);
					 asteroid.radius=5;

					 scene.add(asteroid.createAsteroid());
				//==========================================
			 	

			 	var ambientLight = new THREE.AmbientLight( 0x444444 );
				scene.add( ambientLight );

				var directLight = new THREE.DirectionalLight( 0xffffff ,0.5);
				directLight.position.set(0,0,5);
				scene.add( directLight );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				document.body.appendChild( stats.domElement );


			}



				function cameraSelector() {
					if (currentCamera.cam=="cam1"){
						return camera1;
					} else if (currentCamera.cam=="cam2"){
						return camera2;
					}
				}



				
				window.onload = function() {
					var gui = new dat.GUI();
					gui.add(currentCamera, 'cam', { inspect: "cam1", player: "cam2"} );
					gui.add(asteroid, 'move_active');
					gui.add(asteroid.roll, 'active');
	  			}

				
				function render() {
					requestAnimationFrame(render);
					
					stats.update();
					if(asteroid != undefined){
						asteroid.update();
					}

					if (player1 != undefined) {
						camera2.lookAt(player1.position);
						var relativeCameraOffset = new THREE.Vector3 (0,5,-10);
						var cameraOffset = relativeCameraOffset.applyMatrix4( player1.matrixWorld );

						camera2.position.x = cameraOffset.x;
						camera2.position.y = cameraOffset.y;
						camera2.position.z = cameraOffset.z;
						camera2.rotation.y = 90 * Math.PI / 180;
						camera2.lookAt(player1.position);

						var relativeLaserOffset = new THREE.Vector3 (0.35,-0.95, 8);
						var laserOffset = relativeLaserOffset.applyMatrix4( player1.matrixWorld );
						laser.position.x = laserOffset.x;
						laser.position.y = laserOffset.y;
						laser.position.z = laserOffset.z;
						
						var delta = clock.getDelta(); // seconds.
						var moveDistance = 0.02* delta; // 200 pixels per second

						window.addEventListener('keydown', function(event) {
  							switch (event.keyCode) {
  								case 37: // Left
  								player1.translateX(moveDistance);
  								break;
  								case 38: // Up
  								player1.translateX(moveDistance);
  								break;
  								case 39: // Right
  								 player1.translateX(-moveDistance);
  								 break;
  								 case 40: // Down
  								 player1.translateZ(-moveDistance);
  								 break;
  							}
  						})
						
					}

					renderer.render(scene, cameraSelector());

				}

		</script>
	</body>
</html>